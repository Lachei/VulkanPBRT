#version 460
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_GOOGLE_include_directive : enable

layout(std430, binding = 0) buffer r_mat{
	vec3 r[];
};
layout(binding  = 1, r16f) uniform image2DArray tmp_data;

layout(std430, binding = 2) buffer weights{
	float w[];
};

layout(binding = 3) uniform Data{
	uint frame_number;
};

layout (local_size_x = 16,local_size_y = 16,local_size_z=1) in;

#include "shader_util.h"

shared float tmp_min, tmp_max, tmp_sum;
shared vec3 tmp_vec_sum;
shared float u_vec[16*16];
shared vec3 divider;

void main(){
	float u_length_squared, dott, block_min, block_max, vec_length;
	
	float prod = 0;
	uint id = gl_LocalInvocationID.x * 16 + gl_LocalInvocationID.y;

	// scaling the world positions to 0..1 in a block
	for(int f = 1;f < 7;++f){
		float val = imageLoad(tmp_data,ivec3(gl_GlobalInvocationID.xy,f)).x;
		parallel_reduction_min(tmp_min, val);
		parallel_reduction_max(tmp_max, val);

		val = (val-tmp_min)/(tmp_max - tmp_min);
		imageStore(tmp_data, ivec3(gl_GlobalInvocationID.xy,f),vec4(val));
	}

	int limit = 13;				// limit equals the buffer count

	// Compute R
	for(int col = 0;col<limit;col++){
		int col_limited = min(col, limit - 3);

		float val = imageLoad(tmp_data,ivec3(gl_GlobalInvocationID.xy,col)).x;
		u_vec[id] = val;
		float val2 = val * val;
		float len2;
		float len;
		parallel_reduction_sum(tmp_sum, len2);

		float r_value;
		if( id < col){
			r_value = u_vec[id];
		}else if (id == col){
			len2 += u_vec[col_limited] * u_vec[col_limited];
			len = sqrt(len2);
			u_vec[col_limited] -= len;
			r_value = len;
		}else {
			r_value = 0;
		}

		uint id_limited = min(id, col_limited);
		uint x = col_limited, y = id_limited;
		if(col < col_limited){
			r[R_ACCESS] = vec3(r_value);
		}else{
			int channel = col - limit + 3;
			if(channel == 0)
			   r[R_ACCESS].x = r_value;
			else if(channel == 1)
			   r[R_ACCESS].y = r_value;
			else // channel == 2
			   r[R_ACCESS].z = r_value;
		}
		memoryBarrierBuffer();

		//transforming all other columns of the matrix
		for(int f = col_limited + 1; f<limit; ++f){
			float val = 0;
			if(f >= col_limited){
				 val = imageLoad(tmp_data,ivec3(gl_GlobalInvocationID.xy,f)).x;
				 if(col == 0 && f < limit - 3){
					val = add_random(val, int(id), 0, f, int(frame_number));
				 }
			}
			parallel_reduction_sum(tmp_sum,val);
			if( id >= col_limited){
				val -= 2 * u_vec[id] * tmp_sum / len2;
				imageStore(tmp_data,ivec3(gl_GlobalInvocationID.xy,f),vec4(val));
			}
			memoryBarrier();
		}
	}

	// Back substitution
	for(int i = R_EDGE - 2; i>=0; --i){
		if(id == 0){
			int x = i, y = i;
			divider = r[R_ACCESS];
		}
		memoryBarrierShared();
		vec3 val = vec3(0);
#if COMPRESSED_R
		if(id < R_EDGE && id >= i){
#else
		// First values are always zero if R !COMPRESSED_R and
		// "&& id >= i" makes not compressed code run little bit slower
		if(id < R_EDGE){
#endif
			uint x = id, y = i;
			val = r[R_ACCESS] / divider;
		}
		parallel_reduction_sum(tmp_vec_sum.x,val.x);
		parallel_reduction_sum(tmp_vec_sum.y,val.y);
		parallel_reduction_sum(tmp_vec_sum.z,val.z);
		
		memoryBarrier();
		if(id == 0) //Optimization proposal: parallel reduction
			for(int j = i + 1; j < R_EDGE - 1; j++){
               int x = R_EDGE - 1, y = i;
			   vec3 value = r[R_ACCESS];
               x = j, y = i;
			   vec3 value2 = r[R_ACCESS];
			   x = R_EDGE - 1, y = i;
			   r[R_ACCESS] = value - value2;
			}
		memoryBarrier();
#if COMPRESSED_R
		if(id < R_EDGE && i >= id){
#else
		if(id < R_EDGE){
#endif
            uint x = i, y = id;
			vec3 value = r[R_ACCESS];
            x = R_EDGE - 1, y = i;
			vec3 value2 = r[R_ACCESS];
			x = i, y = id;
			r[R_ACCESS] = value * value2;
		}
		memoryBarrier();
	}

	if(id < limit - 3){
	   // Store weights
	   uint x = R_EDGE - 1, y = id; 
	   uint index = ((gl_WorkGroupID.y * gl_WorkGroupSize.x + gl_WorkGroupID.x) * (limit - 3) + id) * 3;
	   w[index] = r[R_ACCESS].x;
	   w[index + 1] = r[R_ACCESS].y;
	   w[index + 2] = r[R_ACCESS].z;
	}
};