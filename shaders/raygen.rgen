#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba8) uniform image2D outputImage;
layout(binding = 15, set = 0, r32f) uniform image2D depthImage;
layout(binding = 16, set = 0, rg32f) uniform image2D normalImage;
layout(binding = 17, set = 0, rgba8) uniform image2D materialImage;
layout(binding = 18, set = 0, rgba8) uniform image2D albedoImage;
layout(binding = 19, r32f) uniform image2D prevDepth;
layout(binding = 20, rg32f) uniform image2D prvNormal;
layout(binding = 21, r16f) uniform image2D motion;
layout(binding = 22, r8ui) uniform uimage2D sampleCounts;
layout(binding = 23) uniform Infos{
  uint lightCount;
  uint minRecursionDepth;
  uint maxRecursionDepth;
}infos;

layout(push_constant) uniform PushConstants 
{
	mat4 inverseViewMatrix;
	mat4 inverseProjectionMatrix;
	mat4 prevViewProj;
	uint frameNumber;
	uint steadyCamFrame;
} camParams;

#include "general.glsl"

layout(location = 1) rayPayloadEXT RayPayload rayPayload;

uint rayFlags = gl_RayFlagsOpaqueEXT;
uint cullMask = 0xff;
float tmin = 0.001;
float tmax = 10000.0;

vec3 indirectLighting(vec3 pos, vec3 v, SurfaceInfo s, int recDepth){
  vec3 l;
  float pdf;
  vec3 brdf = sampleBRDF(s, rayPayload.re, v, l, pdf);
  if(brdf == vec3(0) || pdf < EPSILON){
    return vec3(0);
  }

  float t = dot(l, s.normal);
  vec3 pathThroughput = rayPayload.throughput * (brdf * dot(l, s.normal)) / pdf;
  if(recDepth > infos.minRecursionDepth) {
    float termination = max(c_MinTermination, 1.0 - max(max(pathThroughput.x, pathThroughput.y),pathThroughput.z));
    if(randomFloat(rayPayload.re) < c_MinTermination){
      return vec3(0);
    }
    pathThroughput /= 1.0 - c_MinTermination;
  }

  rayPayload.throughput = pathThroughput;
  traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, pos, tmin, l, tmax, 1);
  return min(rayPayload.color, vec3(c_MaxRadiance));
}

void main() 
{
	rayPayload.re = rEInit(gl_LaunchIDEXT.xy, camParams.frameNumber);
	rayPayload.throughput = vec3(1);
	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 normalisedPixelCoord = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 clipSpaceCoord = normalisedPixelCoord * 2.0 - 1.0;
	clipSpaceCoord += randomVec2(rayPayload.re) * .001;

	vec4 worldSpacePos = camParams.inverseViewMatrix * vec4(0,0,0,1);
	vec4 viewSpaceDir = camParams.inverseProjectionMatrix * vec4(clipSpaceCoord.x, clipSpaceCoord.y, 1, 1) ;
	vec4 worldSpaceDir = camParams.inverseViewMatrix * vec4(normalize(viewSpaceDir.xyz), 0) ;


	//first hit infos
	traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, worldSpacePos.xyz, tmin, worldSpaceDir.xyz, tmax, 1);

	imageStore(depthImage, ivec2(gl_LaunchIDEXT.xy), vec4(distance(rayPayload.position, worldSpacePos.xyz)));
	imageStore(normalImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.si.normal, 1));
	imageStore(materialImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.reflector));
	imageStore(albedoImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.albedo));

	vec3 prevFrameColor = vec3(1.0/0);
	if(camParams.steadyCamFrame > 0){
		prevFrameColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
	}
	
	//depth recursion
	vec3 finalColor = rayPayload.color;
	if(rayPayload.position != vec3(1.0/0)){
		for(int i = 0; i < infos.maxRecursionDepth; ++i){
			vec3 v = normalize(worldSpacePos.xyz - rayPayload.position);
			worldSpacePos = vec4(rayPayload.position, 1);
			vec3 indir = indirectLighting(worldSpacePos.xyz, v, rayPayload.si, i);
			if(rayPayload.position == vec3(1.0/0)) break;
			finalColor += indir;
		}
	}

	if(prevFrameColor != vec3(1.0/0)){
		float alpha = 1.0 / (camParams.steadyCamFrame + 1);
		finalColor = mix(SRGBtoLINEAR(vec4(prevFrameColor,1)).xyz, finalColor, alpha);
	}

	finalColor = LINEARtoSRGB(vec4(finalColor, 1)).xyz;
	
	imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor,1));
	//imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(albedo));
}
