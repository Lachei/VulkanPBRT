#version 460
#extension GL_EXT_ray_tracing : enable
#pragma import_defines (FINAL_IMAGE, GBUFFER, PREV_GBUFFER, DEMOD_ILLUMINATION, DEMOD_ILLUMINATION_SQUARED)

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
#ifdef FINAL_IMAGE
layout(binding = 1, set = 0, rgba8) uniform image2D outputImage;
#endif
#ifdef GBUFFER
layout(binding = 15, set = 0, r32f) uniform image2D depthImage;
layout(binding = 16, set = 0, rg32f) uniform image2D normalImage;
layout(binding = 17, set = 0, rgba8) uniform image2D materialImage;
layout(binding = 18, set = 0, rgba8) uniform image2D albedoImage;
#endif
#ifdef PREV_GBUFFER
layout(binding = 19) uniform sampler2D prevDepth;
layout(binding = 20) uniform sampler2D prevNormal;
layout(binding = 21, r16f) uniform image2D motion;
layout(binding = 22, r8) uniform image2D sampleCounts;
layout(binding = 24) uniform sampler2D prevSampleCounts;
#endif
#ifdef DEMOD_ILLUMINATION
layout(binding = 23) uniform sampler2D prevOutput;
layout(binding = 25, rgba16f) uniform image2D illumination;
#endif
layout(binding = 26) uniform Infos{
  uint lightCount;
  uint minRecursionDepth;
  uint maxRecursionDepth;
}infos;
#ifdef DEMOD_ILLUMINATION_SQUARED
layout(binding = 27, rgba16f) uniform image2D illuminationSquared;
layout(binding = 28) uniform sampler2D prevIlluminationSquared;
#endif

layout(push_constant) uniform PushConstants 
{
	mat4 inverseViewMatrix;
	mat4 inverseProjectionMatrix;
	mat4 prevView;
	uint frameNumber;
	uint sampleNumber;
} camParams;

#include "general.glsl"

layout(location = 1) rayPayloadEXT RayPayload rayPayload;

uint rayFlags = gl_RayFlagsNoOpaqueEXT | gl_RayFlagsOpaqueEXT;
uint cullMask = 0xff;
float tmin = 0.001;
float tmax = 10000.0;

vec3 indirectLighting(vec3 pos, vec3 v, SurfaceInfo s, int recDepth){
  vec3 l;
  float pdf;
  vec3 brdf = sampleBRDF(s, rayPayload.re, v, l, pdf);
  if(brdf == vec3(0) || pdf < EPSILON){
    return vec3(0);
  }

  float t = dot(l, s.normal);
  vec3 pathThroughput = rayPayload.throughput * (brdf * dot(l, s.normal)) / pdf;
  if(recDepth > infos.minRecursionDepth) {
    float termination = max(c_MinTermination, 1.0 - max(max(pathThroughput.x, pathThroughput.y),pathThroughput.z));
    if(randomFloat(rayPayload.re) < c_MinTermination){
      return vec3(0);
    }
    pathThroughput /= 1.0 - c_MinTermination;
  }

  rayPayload.throughput = pathThroughput;
  traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, pos, tmin, l, tmax, 1);

	//TODO: better firefly suppression (see nvpro samples for a good one)
  return min(rayPayload.color, vec3(c_MaxRadiance));
}

void main() 
{
	rayPayload.re = rEInit(gl_LaunchIDEXT.xy, camParams.frameNumber);
	rayPayload.throughput = vec3(1);
	
	vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(.5);
#ifdef FINAL_IMAGE
#ifndef DEMOD_ILLUMINATION
#ifndef DEMOD_ILLUMINATION_SQUARED
	pixelCenter += randomVec2(rayPayload.re) - .5;	//can not be done when reprojecting
#endif
#endif
#endif
	const vec2 normalisedPixelCoord = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 clipSpaceCoord = normalisedPixelCoord * 2.0 - 1.0;

	vec4 worldSpacePos = camParams.inverseViewMatrix * vec4(0,0,0,1);
	vec4 viewSpaceDir = camParams.inverseProjectionMatrix * vec4(clipSpaceCoord.x, clipSpaceCoord.y, 1, 1) ;
	vec4 worldSpaceDir = camParams.inverseViewMatrix * vec4(normalize(viewSpaceDir.xyz), 0) ;

	//first hit infos
	traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, worldSpacePos.xyz, tmin, worldSpaceDir.xyz, tmax, 1);

	// --------------------------------------------------------------------
	// storing GBuffer information
	// --------------------------------------------------------------------
	vec3 curAlbedo = rayPayload.albedo.xyz;
	float depth = distance(rayPayload.position, worldSpacePos.xyz);
#ifdef GBUFFER
	imageStore(depthImage, ivec2(gl_LaunchIDEXT.xy), vec4(depth));
	vec2 compressedNormal;
	compressedNormal.x = acos(rayPayload.si.normal.z);
	compressedNormal.y = atan(rayPayload.si.normal.y, rayPayload.si.normal.x);
	imageStore(normalImage, ivec2(gl_LaunchIDEXT.xy), vec4(compressedNormal, 1, 1));
	imageStore(materialImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.reflector));
	imageStore(albedoImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.albedo));
#endif

	// --------------------------------------------------------------------
	// accumulation information
	// --------------------------------------------------------------------
 	vec3 prevColor;
	vec3 prevColorSquared;
	vec3 prevNor;
	float truePrevDepth;
	bool reprojected = false;
	float pixelSpp = 1.0 / 256.0; //has to be normalized as only floating point 8 bit interp is supported
#if defined PREV_GBUFFER && defined GBUFFER && (defined DEMOD_ILLUMINATION || defined DEMOD_ILLUMINATION_SQUARED)
	mat4 prevProj = inverse(camParams.inverseProjectionMatrix);
	vec4 p = vec4(rayPayload.position, 1);
	vec4 prevPos = camParams.prevView * p;
	float preDepth = length(prevPos.xyz);
	prevPos = prevProj * prevPos;
	prevPos /= prevPos.w; // xy now holds the prev image position
	prevPos.xy += 1;
	prevPos.xy *= .5;
	ivec2 prevPixelIndex = ivec2(prevPos.xy * (gl_LaunchSizeEXT.xy - vec2(1)) + .5f);
	if(isinf(rayPayload.position.x)) pixelSpp = 0;
	if(camParams.frameNumber > 0 && !isinf(rayPayload.position.x)){
		//depth check
		truePrevDepth = texture(prevDepth, prevPos.xy).x;
		float depthDissim = (truePrevDepth / preDepth) - 1;	//using relative error of depths to blend pixels further away form camera together
		if(all(greaterThanEqual(prevPos.xy, vec2(0))) && all(lessThanEqual(prevPos.xy, vec2(1))) && abs(depthDissim) <= .01f){		//dissimilarity in depth values shoudl be smaller than 1%
			//normal check
			prevNor = texture(prevNormal, prevPos.xy).xyz;
			prevNor = vec3(sin(prevNor.x) * cos(prevNor.y), sin(prevNor.x) * sin(prevNor.y), cos(prevNor.x));
			if(dot(rayPayload.si.normal, prevNor) > .9f){	//we do have a point which can be reprojected
				reprojected = true;
			#ifdef DEMOD_ILLUMINATION
				prevColor = texture(prevOutput, prevPos.xy).xyz;
			#endif
			#ifdef DEMOD_ILLUMINATION_SQUARED
				prevColorSquared = texture(prevIlluminationSquared, prevPos.xy).xyz;
			#endif
				pixelSpp += texture(prevSampleCounts, prevPos.xy).x;
			}
		}
	}
	if(reprojected){
		imageStore(motion, ivec2(gl_LaunchIDEXT.xy), vec4(prevPos.xy, 1, 1));
	}
	else{
		imageStore(motion, ivec2(gl_LaunchIDEXT.xy), vec4(-1));
	}
	imageStore(sampleCounts, ivec2(gl_LaunchIDEXT.xy), vec4(pixelSpp));
#endif

	// --------------------------------------------------------------------
	//depth recursion
	// --------------------------------------------------------------------
	vec3 finalColor = rayPayload.color;
#if defined FINAL_IMAGE || defined DEMOD_ILLUMINATION || defined DEMOD_ILLUMINATION_SQUARED
	if(rayPayload.position != vec3(1.0/0)){
		for(int i = 0; i < infos.maxRecursionDepth; ++i){
			vec3 v = normalize(worldSpacePos.xyz - rayPayload.position);
			worldSpacePos = vec4(rayPayload.position, 1);
			vec3 indir = indirectLighting(worldSpacePos.xyz, v, rayPayload.si, i);
			finalColor += indir;
		}
	}
#endif

	// --------------------------------------------------------------------
	// final color calculations
	// --------------------------------------------------------------------
	finalColor = clamp(finalColor, 0, c_MaxRadiance);
#if defined DEMOD_ILLUMINATION || defined DEMOD_ILLUMINATION_SQUARED
	vec3 demodulated = finalColor;
	if(!isinf(rayPayload.position.x))
		demodulated /= (curAlbedo.xyz + vec3(EPSILON));	// epsilon added to avoid divion by 0 (when color is remodulated, epsilon is added to albedo)
	vec3 demodSquared = demodulated * demodulated;
	if(reprojected){
		float blendAlpha = max(1.f / (pixelSpp * 256.0), BLEND_ALPHA);
		demodulated = mix(prevColor, demodulated, blendAlpha);
		demodSquared = mix(prevColorSquared, demodSquared, blendAlpha);
	}
	#ifdef DEMOD_ILLUMINATION
	imageStore(illumination, ivec2(gl_LaunchIDEXT.xy), vec4(demodulated, 1));
	#endif
	#ifdef DEMOD_ILLUMINATION_SQUARED
	imageStore(illuminationSquared, ivec2(gl_LaunchIDEXT.xy), vec4(demodSquared, 1));
	#endif
#endif

#ifdef FINAL_IMAGE
	vec3 prevFrameColor = vec3(1.0/0);
	if(camParams.sampleNumber > 0){
		prevFrameColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
		float alpha = 1.0 / (camParams.sampleNumber + 1);
		finalColor = mix(SRGBtoLINEAR(vec4(prevFrameColor,1)).xyz, finalColor, alpha);
	}

	finalColor = LINEARtoSRGB(vec4(finalColor, 1)).xyz;
	finalColor = clamp(finalColor, vec3(0), vec3(1));
	
	imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1));
#endif
}
