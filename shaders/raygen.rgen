#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 1, set = 0, rgba8) uniform image2D outputImage;
layout(binding = 15, set = 0, r32f) uniform image2D depthImage;
layout(binding = 16, set = 0, rg32f) uniform image2D normalImage;
layout(binding = 17, set = 0, rgba8) uniform image2D materialImage;
layout(binding = 18, set = 0, rgba8) uniform image2D albedoImage;
layout(binding = 19) uniform sampler2D prevDepth;
layout(binding = 20) uniform sampler2D prevNormal;
layout(binding = 21, r16f) uniform image2D motion;
layout(binding = 22, r8) uniform image2D sampleCounts;
layout(binding = 23) uniform sampler2D prevOutput;
layout(binding = 24) uniform sampler2D prevSampleCounts;
layout(binding = 25, rgba16f) uniform image2D illumination;
layout(binding = 26) uniform Infos{
  uint lightCount;
  uint minRecursionDepth;
  uint maxRecursionDepth;
}infos;
layout(binding = 27, rgba16f) uniform image2D illuminationSquared;
layout(binding = 28) uniform sampler2D prevIlluminationSquared;

layout(push_constant) uniform PushConstants 
{
	mat4 inverseViewMatrix;
	mat4 inverseProjectionMatrix;
	mat4 prevView;
	uint frameNumber;
	uint steadyCamFrame;
} camParams;

#include "general.glsl"

layout(location = 1) rayPayloadEXT RayPayload rayPayload;

uint rayFlags = gl_RayFlagsOpaqueEXT;
uint cullMask = 0xff;
float tmin = 0.001;
float tmax = 10000.0;

vec3 indirectLighting(vec3 pos, vec3 v, SurfaceInfo s, int recDepth){
  vec3 l;
  float pdf;
  vec3 brdf = sampleBRDF(s, rayPayload.re, v, l, pdf);
  if(brdf == vec3(0) || pdf < EPSILON){
    return vec3(0);
  }

  float t = dot(l, s.normal);
  vec3 pathThroughput = rayPayload.throughput * (brdf * dot(l, s.normal)) / pdf;
  if(recDepth > infos.minRecursionDepth) {
    float termination = max(c_MinTermination, 1.0 - max(max(pathThroughput.x, pathThroughput.y),pathThroughput.z));
    if(randomFloat(rayPayload.re) < c_MinTermination){
      return vec3(0);
    }
    pathThroughput /= 1.0 - c_MinTermination;
  }

  rayPayload.throughput = pathThroughput;
  traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, pos, tmin, l, tmax, 1);
  for(int i = 0; i < 5 && rayPayload.albedo.a == 0; ++i){
	pos = rayPayload.position.xyz;
	traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, pos, tmin, l, tmax, 1);
  }
  return min(rayPayload.color, vec3(c_MaxRadiance));
}

void main() 
{
	rayPayload.re = rEInit(gl_LaunchIDEXT.xy, camParams.frameNumber);
	rayPayload.throughput = vec3(1);
	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(.5);
	const vec2 normalisedPixelCoord = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 clipSpaceCoord = normalisedPixelCoord * 2.0 - 1.0;
	//clipSpaceCoord += randomVec2(rayPayload.re) * .001;	//can not be done when reprojecting

	vec4 worldSpacePos = camParams.inverseViewMatrix * vec4(0,0,0,1);
	vec4 viewSpaceDir = camParams.inverseProjectionMatrix * vec4(clipSpaceCoord.x, clipSpaceCoord.y, 1, 1) ;
	vec4 worldSpaceDir = camParams.inverseViewMatrix * vec4(normalize(viewSpaceDir.xyz), 0) ;


	//first hit infos
	traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, worldSpacePos.xyz, tmin, worldSpaceDir.xyz, tmax, 1);
	for(int i = 0; i < 5 && rayPayload.albedo.a == 0; ++i){
		worldSpacePos.xyz = rayPayload.position.xyz;
		traceRayEXT(tlas, rayFlags, cullMask, 0, 0, 0, worldSpacePos.xyz, tmin, worldSpaceDir.xyz, tmax, 1);
	}

	imageStore(depthImage, ivec2(gl_LaunchIDEXT.xy), vec4(distance(rayPayload.position, worldSpacePos.xyz)));
	vec2 compressedNormal;
	compressedNormal.x = acos(rayPayload.si.normal.z);
	compressedNormal.y = atan(rayPayload.si.normal.y / rayPayload.si.normal.x);
	imageStore(normalImage, ivec2(gl_LaunchIDEXT.xy), vec4(compressedNormal, 1, 1));
	imageStore(materialImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.reflector));
	vec3 curAlbedo = rayPayload.albedo.xyz;
	imageStore(albedoImage, ivec2(gl_LaunchIDEXT.xy), vec4(rayPayload.albedo));

	//accumulation with previous frames
	mat4 prevProj = inverse(camParams.inverseProjectionMatrix);
	bool reprojected = false;
	vec4 p = vec4(rayPayload.position, 1);
	vec4 prevPos = camParams.prevView * p;
	float preDepth = length(prevPos.xyz);
	prevPos = prevProj * prevPos;
	prevPos /= prevPos.w; // xy now holds the prev image position
	prevPos.xy += 1;
	prevPos.xy *= .5;
	ivec2 prevPixelIndex = ivec2(prevPos.xy * (gl_LaunchSizeEXT.xy - vec2(1)) + .5f);
	float pixelSpp = 1.0 / 256.0; //has to be normalized as only floating point 8 bit interp is supported
	if(isinf(rayPayload.position.x)) pixelSpp = 0;
 	vec3 prevColor;
	vec3 prevColorSquared;
	vec3 prevNor;
	float truePrevDepth;
	if(camParams.frameNumber > 0 && !isinf(rayPayload.position.x)){
		//depth check
		truePrevDepth = texture(prevDepth, prevPos.xy).x;
		float depthDissim = (truePrevDepth / preDepth) - 1;	//using relative error of depths to blend pixels further away form camera together
		if(all(greaterThanEqual(prevPos.xy, vec2(0))) && all(lessThanEqual(prevPos.xy, vec2(1))) && abs(depthDissim) <= .01f){		//dissimilarity in depth values shoudl be smaller than 1%
			//normal check
			prevNor = texture(prevNormal, prevPos.xy).xyz;
			prevNor = vec3(sin(prevNor.x) * cos(prevNor.y), sin(prevNor.x) * sin(prevNor.y), cos(prevNor.x));
			//if(dot(rayPayload.si.normal, prevNor) > .9f){	//we do have a point which can be reprojected
				reprojected = true;
				prevColor = texture(prevOutput, prevPos.xy).xyz;
				prevColorSquared = texture(prevIlluminationSquared, prevPos.xy).xyz;
				pixelSpp += texture(prevSampleCounts, prevPos.xy).x;
			//}
		}
	}
	if(reprojected){
		imageStore(motion, ivec2(gl_LaunchIDEXT.xy), vec4(prevPos.xy, 1, 1));
	}
	else{
		imageStore(motion, ivec2(gl_LaunchIDEXT.xy), vec4(-1));
	}
	imageStore(sampleCounts, ivec2(gl_LaunchIDEXT.xy), vec4(pixelSpp));

	//final image color 
	vec3 prevFrameColor = vec3(1.0/0);
	if(camParams.steadyCamFrame > 0){
		prevFrameColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
	}
	
	//depth recursion
	vec3 finalColor = rayPayload.color;
	if(rayPayload.position != vec3(1.0/0)){
		for(int i = 0; i < infos.maxRecursionDepth; ++i){
			vec3 v = normalize(worldSpacePos.xyz - rayPayload.position);
			worldSpacePos = vec4(rayPayload.position, 1);
			vec3 indir = indirectLighting(worldSpacePos.xyz, v, rayPayload.si, i);
			if(rayPayload.position == vec3(1.0/0)) break;
			finalColor += indir;
		}
	}

	vec3 demodulated = finalColor;
	if(!isinf(rayPayload.position.x))
		demodulated /= (curAlbedo.xyz + vec3(EPSILON));
	vec3 demodSquared = demodulated * demodulated;
	if(reprojected){
		float blendAlpha = max(1.f / (pixelSpp * 256.0), BLEND_ALPHA);
		demodulated = mix(prevColor, demodulated, blendAlpha);
		demodSquared = mix(prevColorSquared, demodulated, blendAlpha);
	}

	if(prevFrameColor != vec3(1.0/0)){
		float alpha = 1.0 / (camParams.steadyCamFrame + 1);
		finalColor = mix(SRGBtoLINEAR(vec4(prevFrameColor,1)).xyz, finalColor, alpha);
	}

	finalColor = LINEARtoSRGB(vec4(finalColor, 1)).xyz;
	
	imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1));
	imageStore(illumination, ivec2(gl_LaunchIDEXT.xy), vec4(demodulated, 1));
	imageStore(illuminationSquared, ivec2(gl_LaunchIDEXT.xy), vec4(demodSquared, 1));
}
